// (c) 2019-2020, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

package eventtokenizervm

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"time"

	"github.com/ava-labs/avalanchego/ids"
	"github.com/ava-labs/avalanchego/snow/consensus/snowman"
	"github.com/ava-labs/avalanchego/vms/components/core"

	log "github.com/inconshreveable/log15"
)

var (
	errTimestampTooEarly = errors.New("block's timestamp is earlier than its parent's timestamp")
	errDatabaseGet       = errors.New("error while retrieving data from database")
	errDatabaseSave      = errors.New("error while saving block to the database")
	errTimestampTooLate  = errors.New("block's timestamp is more than 1 hour ahead of local time")
	errBlockType         = errors.New("unexpected block type")

	_ snowman.Block = &Block{}
)

type Block struct {
	*core.Block `serialize:"true"`
	// Block.ID() // Generated by SYSTEM. It is referred as EventID in design & documentation.
	// Block.Timestamp() // Generated by SYSTEM. Its value is block generation time. It is referred as Timestamp in design & documentation.
	SequenceID     ids.ID      `serialize:"true"` // Passed by USER. Expected value is a previously SYSTEM generated block.ID()
	CodecAddress   ids.ShortID `serialize:"true"` // Passed by USER. Expected value is a C-Chain contract address, that would have logic to Encode-Decode the event data.
	EncodedData    []byte      `serialize:"true"` // Passed by USER. Expected value is the encoded event data, ideally a JSON object.
	RefID          []byte      `serialize:"true"` // Passed by USER. Expected value is a randomly generated Unique ID from the integrating system.
	RefTime        int64       `serialize:"true"` // Passed by USER. Expected value is the actual event time.
	CreatorAddress ids.ShortID `serialize:"true"` // Passed by USER. The Account that has signed this block.
}

// Verify returns nil iff this block is valid.
// To be valid, it must be that:
// b.parent.Timestamp < b.Timestamp <= [local time] + 1 hour
func (b *Block) Verify() error {
	// Check to see if this block has already been verified by calling Verify on the
	// embedded *core.Block.
	// If there is an error while checking, return an error.
	// If the core.Block says the block is accepted, return accepted.
	if accepted, err := b.Block.Verify(); err != nil || accepted {
		return err
	}

	// Get [b]'s parent
	parentID := b.Parent()
	parentIntf, err := b.VM.GetBlock(parentID)
	if err != nil {
		return errDatabaseGet
	}
	parent, ok := parentIntf.(*Block)
	if !ok {
		return errBlockType
	}

	// Ensure [b]'s timestamp is after its parent's timestamp.
	if b.Timestamp().Unix() < parent.Timestamp().Unix() {
		return errTimestampTooEarly
	}

	// Ensure [b]'s timestamp is not more than an hour
	// ahead of this node's time
	if b.Timestamp().Unix() >= time.Now().Add(time.Hour).Unix() {
		return errTimestampTooLate
	}

	// Our block inherits VM from *core.Block.
	// It holds the database we read/write, b.VM.DB
	// We persist this block to that database using VM's SaveBlock method.
	if err := b.VM.SaveBlock(b.VM.DB, b); err != nil {
		return errDatabaseSave
	}

	// Then we flush the database's contents
	errDb := b.VM.DB.Commit()
	//log.Info(fmt.Sprintf("errDb: %v", errDb))

	if cfgEnableIndexer && errDb == nil {
		b.NotifyIndexer()
	}

	return errDb
}

type IndexerResponse struct {
	StatusCode int    `json:"statusCode"`
	Message    string `json:"message"`
}

// for custom event indexer service,
// implementing a simple http push-pull design (blocking),
// An elaborate pub-sub design would be tasked later.
func (b *Block) NotifyIndexer() {
	defer func() {
		if panicInfo := recover(); panicInfo != nil {
			//err := fmt.Errorf("%v, %s", panicInfo, string(debug.Stack()))
			//log.Error(err.Error())
			log.Error(fmt.Sprintf("NotifyIndexer:: panicInfo:%v", panicInfo))
			return
		}
	}()

	sequenceIDStr := b.SequenceID.String()
	//if sequenceIDStr == ids.Empty.String() {
	//	sequenceIDStr = b.ID().String()
	//}
	values := map[string]string{"eventid": b.ID().String(), "sequenceid": sequenceIDStr, "timestamp": fmt.Sprintf("%v", b.Timestamp().Unix()), "refid": fmt.Sprintf("%v", b.RefID), "reftime": fmt.Sprintf("%v", b.RefTime), "creator": fmt.Sprintf("%v", b.CreatorAddress)}

	json_data, err := json.Marshal(values)
	if err != nil {
		log.Error(fmt.Sprintf("NotifyIndexer:: Json Marshal Error - %v", err))
	}
	//log.Debug(fmt.Sprintf("NotifyIndexer:: Json Data - %v", json_data))

	resp, err := http.Post(cfgIndexerUri, "application/json", bytes.NewBuffer(json_data))
	if err != nil {
		log.Error(fmt.Sprintf("NotifyIndexer:: Err:%v", err))
	}
	if resp.StatusCode != 200 {
		log.Error(fmt.Sprintf("NotifyIndexer:: Failure response - StatusCode:%v, for block:%v", resp.StatusCode, b.ID()))
	} else {
		log.Debug(fmt.Sprintf("NotifyIndexer:: Success response - StatusCode:%v, for block:%v", resp.StatusCode, b.ID()))
	}
	return
}
